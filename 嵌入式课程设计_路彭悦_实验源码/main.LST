C51 COMPILER V9.01   MAIN                                                                  01/20/2018 01:06:38 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /**************************************************************
   2          * 程 序 名         : 电子音乐播放器
   3          * 功能描述                 : K1开始播放；
   4          K2暂停/继续播放；
   5          K3播放下一首；
   6          K4播放上一首；
   7                                                   矩阵键盘选音乐；
   8          LCD与LED显示相关信息；
   9          串口通信用APP远程控制播放器。
  10          * 输    入         : 按键或APP输入数字
  11          * 输    出         : 播放相对应音乐
  12          ****************************************************************/
  13          #include<reg52.h>
  14          #include<intrins.h>
  15          #define uchar unsigned char
  16          #define uint unsigned int 
  17          #define GPIO_DIG P0
  18          #define GPIO_KEY P1
  19          
  20          uint code smgduan[17]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,
  21                                                         0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};
  22          //显示0~F的值
  23          sbit LSA=P2^2;
  24          sbit LSB=P2^3;
  25          sbit LSC=P2^4;
  26          sbit K1=P3^1;
  27          sbit K2=P3^0;
  28          sbit K3=P3^2;
  29          sbit K4=P3^3;
  30          sbit Beep=P1^5;       
  31          sbit rs=P2^6;
  32          sbit rw=P2^5;
  33          sbit ep=P2^7;
  34          
  35          uchar KeyValue=0;                                       //用来存放读取到的键值
  36          uchar i;
  37          uchar Song_Index=0;
  38          uchar Tone_Index=0;                              //音乐片段索引，音符索引
  39          uchar *Song_Tone,*Song_Time;             //音符指针，延时指针
  40          uchar *discode;                                          //暂存LCD需要显示的歌名
  41          uchar dis1[]="  1.Song Bie0";            //第一首歌名dis1~dis5为LCD第一行显示内容
  42          uchar dis2[]="2.LiangZhiLaoHu0";//第二首歌名
  43          uchar dis3[]="  3.Ha Ba Gou0";           //第三首歌名
  44          uchar dis4[]=" 4.Lan Hua Cao0";  //第四首歌名
  45          uchar dis5[]=" 5.Bu Dao Weng0";  //第五首歌名
  46          uchar dis[]=" K3:Down K4:UP0";           //LCD第二行显示内容
  47          uchar disp[8];
  48          
  49          uint code Tone_tab[]={                           //音符频率对应的T计数值
  50           62018,62401,62419,62895,63184,63441,63506,
  51           63773,63965,64137,64215,64360,64488,64603,
  52           64654,64751,64836,64876,64948,65012,65067,65535
  53           };
  54          
  55          /*第一首音乐*/
C51 COMPILER V9.01   MAIN                                                                  01/20/2018 01:06:38 PAGE 2   

  56           uchar code Song1_Tone[]={                                                              
  57            11,9,11,14,12,14,12,11,11,7,8,9,8,7,8,                        //第一行曲子音符
  58            11,9,11,14,13,12,14,11,11,7,8,9,6,7,                          //第二行曲子音符
  59            12,14,14,13,12,13,14,12,13,14,12,12,11,10,7,8,        //第三行曲子音符
  60            11,9,11,14,13,12,14,11,11,8,9,10,6,7,0xff                     //第四行曲子音符
  61           };
  62          
  63           uchar code Song1_Time[]={                                                        
  64           4,2,2,8,4,2,2,8,4,2,2,4,2,2,12,                                        //第一行曲子节拍
  65            4,2,2,4,2,4,4,8,4,2,2,4,2,12,                                         //第二行曲子节拍
  66            4,4,8,4,2,2,8,2,2,2,2,2,2,2,2,16,                             //第三行曲子节拍
  67            4,2,2,4,2,4,4,8,4,2,2,4,2,12,0xff                                     //第四行曲子节拍
  68           };
  69          
  70          /*第二首音乐*/
  71           uchar code Song2_Tone[]={                                                
  72           7,8,9,7,7,8,9,7,9,10,11,9,10,11,                                       //第一行曲子音符
  73          11,12,11,10,9,7,11,12,11,10,9,7,7,4,7,7,4,7,0xff        //第二行曲子音符
  74           };
  75          
  76           uchar code Song2_Time[]={
  77           4,4,4,4,4,4,4,4,4,4,8,4,4,8,                                             //第一行曲子节拍
  78           2,2,2,2,4,4,2,2,2,2,4,4,4,4,8,4,4,8,0xff                         //第二行曲子节拍
  79           };
  80          
  81          /*第三首音乐*/
  82           uchar code Song3_Tone[]={
  83            7,7,7,8,9,9,9,9,10,11,12,12,11,10,9,11,11,8,9,7,      //第一行曲子音符
  84            7,7,7,8,11,9,9,9,10,11,12,12,11,10,9,11,11,8,9,7      //第二行曲子音符
  85           ,0xff
  86          };
  87           
  88           uchar code Song3_Time[]={
  89             2,2,2,2,4,2,2,2,2,4,2,2,2,2,4,2,2,2,2,4,                     //第一行曲子节拍
  90             2,2,2,2,4,2,2,2,2,4,2,2,2,2,4,2,2,2,2,5,0xff         //第二行曲子节拍
  91           };     
  92           
  93          /*第四首音乐*/
  94           uchar code Song4_Tone[]={      
  95            5,9,9,9,9,8,7,8,7,6,5,12,12,12,12,12,11,                        //第一行曲子音符
  96            2,11,11,10,9,9,12,12,11,9,8,7,8,7,6,5,9,                //第二行曲子音符
  97            2,7,7,6,5,9,8,7,6,4,12,0xff                                             //第三行曲子音符
  98           };     
  99           
 100           uchar code Song4_Time[]={
 101             2,2,2,2,2,2,2,2,2,2,8,2,2,2,2,4,2,                             //第一行曲子节拍
 102             2,2,2,2,8,2,2,2,2,4,2,2,2,2,2,4,2,                             //第二行曲子节拍
 103             2,2,2,2,4,2,2,2,2,2,8,0xff                                             //第二行曲子节拍
 104           };     
 105           
 106          /*第五首曲子*/
 107           uchar code Song5_Tone[]={
 108             11,12,11,9,8,9,11,9,8,7,9,11,7,9,8,                            //第一行曲子音符
 109             11,12,11,9,8,9,11,9,8,7,8,7,8,9,7,0xff                         //第二行曲子音符
 110           };     
 111           
 112           uchar code Song5_Time[]={ 
 113                  4,4,8,4,4,8,4,4,4,4,2,2,2,2,8,                                    //第一行曲子节拍
 114                  4,4,8,4,4,8,4,4,4,4,2,2,2,2,8,0xff                                //第二行曲子节拍
 115           };
 116           /**************************************************************
 117          * 函 数 名         : delayms
C51 COMPILER V9.01   MAIN                                                                  01/20/2018 01:06:38 PAGE 3   

 118          * 函数功能                 : 延时nms
 119          * 输    入         : 需要延迟的时间
 120          * 输    出         : 无
 121          ****************************************************************/                 
 122           void delayms(uint ms)                                                            {                                                         
 123   1              uchar a;
 124   1              while(ms--)
 125   1              {
 126   2                      for(a=230;a>0;a--);
 127   2              }
 128   1       } 
 129          
 130          /**************************************************************
 131          * 函 数 名         : KeyDown
 132          * 函数功能                 : 检测有按键按下并读取键值
 133          * 输    入         : 无
 134          * 输    出         : 无
 135          ****************************************************************/
 136          void KeyDown(void)
 137          {
 138   1      
 139   1              uchar a=0;
 140   1              GPIO_KEY=0x0f;
 141   1              if(GPIO_KEY!=0x0f)                                              //读取按键是否按下
 142   1              {
 143   2                      delayms(10);                                            //延时10ms进行消抖
 144   2                      if(GPIO_KEY!=0x0f)                                      //再次检测键盘是否按下
 145   2                      {                                                                       //测试列
 146   3                              GPIO_KEY=0x0f;
 147   3                              switch(GPIO_KEY)
 148   3                              {
 149   4                                      case(0x07):     KeyValue=0;break;
 150   4                                      case(0x0b):     KeyValue=1;break;
 151   4                                      case(0x0d):     KeyValue=2;break;
 152   4                                      case(0x0e):     KeyValue=3;break;
 153   4                              }
 154   3                              GPIO_KEY=0xF0;                                  //测试行
 155   3                              switch(GPIO_KEY)
 156   3                              {
 157   4                                      case(0x70):     KeyValue=KeyValue;break;
 158   4                                      case(0xb0):     KeyValue=KeyValue+4;break;
 159   4                                      case(0xd0):     KeyValue=KeyValue+8;break;
 160   4                                      case(0xe0):     KeyValue=KeyValue+12;break;
 161   4                              }
 162   3                              while((a<50)&&(GPIO_KEY!=0xf0)) //检测按键松手检测
 163   3                              {
 164   4                                      delayms(10);
 165   4                                      a++;
 166   4                              }
 167   3                              KeyValue++;
 168   3                      }
 169   2              }
 170   1              if(KeyValue>=5)
 171   1                      KeyValue=5;
 172   1      
 173   1      }
 174          
 175          /**************************************************************
 176          * 函 数 名         : Busy_Check
 177          * 函数功能                 : 测试LCD忙碌状态
 178          * 输    入         : 无
 179          * 输    出         : 0or1
C51 COMPILER V9.01   MAIN                                                                  01/20/2018 01:06:38 PAGE 4   

 180          ****************************************************************/
 181           uchar Busy_Check(void)
 182          {
 183   1         uchar LCD_Status;
 184   1         rs=0;                                 
 185   1         rw=1;
 186   1         ep=1;
 187   1         _nop_();
 188   1         _nop_();
 189   1         _nop_();
 190   1         _nop_();
 191   1         LCD_Status = P0&0x80;
 192   1         ep = 0;
 193   1         return LCD_Status;
 194   1       }
 195          
 196          /**************************************************************
 197          * 函 数 名         : LCD_WCMD
 198          * 函数功能                 : 写入指令数据到LCD
 199          * 输    入         : 指令
 200          * 输    出         : 无
 201          ****************************************************************/
 202           void LCD_WCMD(uchar cmd)   
 203           {
 204   1              while(Busy_Check());            //等待LCD空闲
 205   1              rs=0;                                           //选择发送命令
 206   1              rw=0;                                           //选择写入
 207   1              ep=0;                                           //使能
 208   1              _nop_();
 209   1              _nop_();
 210   1              P0=cmd;                                         //P0接受到指令
 211   1              _nop_();                                        //等待时序稳定
 212   1              _nop_();
 213   1              _nop_();
 214   1              _nop_();
 215   1              ep=1;                                            //写入时序
 216   1              _nop_();
 217   1              _nop_();
 218   1              _nop_();
 219   1              _nop_();
 220   1              ep=0;                                            //使能
 221   1       
 222   1       }
 223          
 224           void LCD_POS(uchar pos)                //设置显示位置
 225           {
 226   1              LCD_WCMD(pos|0x80);             //设置LCD当前光标位置
 227   1       }                                                      
 228          
 229          /**************************************************************
 230          * 函 数 名         : LCD_WDAT
 231          * 函数功能                 : 写入字符到LCD
 232          * 输    入         : 字符
 233          * 输    出         : 无
 234          ****************************************************************/
 235           void LCD_WDAT(uchar dat)       
 236          {
 237   1              while(Busy_Check());
 238   1              rs=1;                                           //选择输入数据 
 239   1              rw=0;                                           //选择写入
 240   1              ep=0;                                           //使能清零
 241   1              P0=dat;
C51 COMPILER V9.01   MAIN                                                                  01/20/2018 01:06:38 PAGE 5   

 242   1              _nop_();
 243   1              _nop_();
 244   1              _nop_();
 245   1              _nop_();
 246   1              ep=1;
 247   1              _nop_();
 248   1              _nop_();
 249   1              _nop_();
 250   1              _nop_();
 251   1              ep=0;
 252   1       }
 253          
 254          /**************************************************************
 255          * 函 数 名         : LCD_Init
 256          * 函数功能                 : LCD初始化设定
 257          * 输    入         : 无
 258          * 输    出         : 无
 259          ****************************************************************/
 260           void LCD_Init(void)    
 261           {
 262   1              LCD_WCMD(0x38);                 //设置显示格式为16*2行显示，5*7点阵，8位
 263   1              LCD_WCMD(0x0c);         //开显示不显示光标
 264   1              LCD_WCMD(0x06);                 //读写后指针加1
 265   1              LCD_WCMD(0x01);                 //清除LCD的显示内容
 266   1      }
 267          
 268          /**************************************************************
 269          * 函 数 名         : Int0()     interrupt 0
 270          * 函数功能                 : 中断服务程序播放下一首音乐
 271          * 输    入         : 按下K3
 272          * 输    出         : 播放音乐
 273          ****************************************************************/
 274           void Int0()    interrupt 0    
 275           {
 276   1              LCD_WCMD(0x01); 
 277   1              delayms(100);
 278   1              if(INT0==0)                                      //按键按下
 279   1              {
 280   2                      TR0=0;                                   //打开定时器0
 281   2                      if (KeyValue == 5)
 282   2                      {
 283   3                              KeyValue=1;
 284   3                      }
 285   2                      else
 286   2                      {
 287   3                              KeyValue++;
 288   3                      }
 289   2                              TR0=1;
 290   2                              i=0;
 291   2              }
 292   1       }
 293          
 294          /**************************************************************
 295          * 函 数 名         : Int1()     interrupt 2
 296          * 函数功能                 : 中断服务程序播放上一首音乐
 297          * 输    入         : 按下K4
 298          * 输    出         : 播放音乐
 299          ****************************************************************/
 300          void Int1()     interrupt 2                     
 301          {
 302   1              LCD_WCMD(0x01);                                 //消除重影(比如Lan Hua Cao 后面会多ao H)
 303   1              delayms(100);
C51 COMPILER V9.01   MAIN                                                                  01/20/2018 01:06:38 PAGE 6   

 304   1              if(INT1==0)                                             //如果按键按下
 305   1              {
 306   2                      TR1=0;
 307   2                      if (KeyValue == 1)
 308   2                      {
 309   3                              KeyValue=5;
 310   3                      }
 311   2                      else
 312   2                      {
 313   3                              KeyValue--;
 314   3                      }
 315   2              
 316   2                      TR1=1;
 317   2                      i=0;
 318   2              }  
 319   1      }
 320          
 321          void Timer0()   interrupt 1
 322          {
 323   1              TH0=Tone_tab[Tone_Index]/256;  //重置T0定时初值
 324   1              TL0=Tone_tab[Tone_Index]%256;
 325   1              Beep=~Beep;
 326   1      }
 327          
 328          /**************************************************************
 329          * 函 数 名         : LCD_disp
 330          * 函数功能                 : LCD显示
 331          * 输    入         : 字符串
 332          * 输    出         : 当前音乐信息
 333          ****************************************************************/
 334          void LCD_disp(void)
 335          {
 336   1              uchar i;
 337   1              LCD_POS(0);                                               //设置显示位为第一行第一个字符
 338   1              i=0;
 339   1              while(discode[i]!='0')                    //显示第一行字符串
 340   1              {
 341   2                      LCD_WDAT(discode[i]);
 342   2                      i++;
 343   2              }
 344   1              LCD_POS(0x40);                                    //设置显示位为第二行第一个字符
 345   1              i=0;
 346   1              while(dis[i]!='0')
 347   1              {
 348   2                      LCD_WDAT(dis[i]);                         //显示第二行  UP&DOWN
 349   2                      i++;
 350   2              }
 351   1      }
 352          
 353          /**************************************************************
 354          * 函 数 名         : Usart() interrupt 4
 355          * 函数功能                 : 串口中断
 356          * 输    入         : 数组
 357          * 输    出         : 选择的音乐
 358          ****************************************************************/
 359          void Usart() interrupt 4
 360          {
 361   1              uint receiveData;
 362   1              uint num[3];                                    //添加通信协议
 363   1              uint i;
 364   1              for(i=0;i<3;i++)
 365   1              {
C51 COMPILER V9.01   MAIN                                                                  01/20/2018 01:06:38 PAGE 7   

 366   2                      while(!RI);
 367   2                      num[i]=SBUF;                        //接收数字
 368   2                      RI = 0;                                         //清除接收中断标志位
 369   2              }
 370   1              if(num[0]== 0 && num[2]== 0)    //判断是否符合通信协议
 371   1               {
 372   2                      receiveData = num[1];
 373   2               }
 374   1              KeyValue = receiveData;
 375   1              EA=1;
 376   1      }        
 377          
 378          /**************************************************************
 379          * 函 数 名         : int_init
 380          * 函数功能                 : 初始化设置
 381          * 输    入         : 无
 382          * 输    出         : 无
 383          ****************************************************************/
 384          void int_init(void)
 385          {
 386   1              ET0=1;                                          //允许Timer0中断
 387   1              EX0=1;                                                  //允许INT0中断
 388   1              IT0=1;                                                  //INT0为边沿触发
 389   1              EX1=1;                                                  //允许INT1中断
 390   1              IT1=1;                                                  //INT1为边沿触发
 391   1              EA=0;                                                   //关闭总中断
 392   1              TR0=0;                                                  //Timer0停止
 393   1      
 394   1              SCON=0X50;                                              //设置为工作方式1
 395   1              TMOD=0X20;                                              //设置计数器工作方式2
 396   1              PCON=0X80;                                              //波特率加倍
 397   1              TH1=0XF3;                                               //计数器初始值设置，将波特率设置为4800
 398   1              TL1=0XF3;
 399   1              ES=1;                                                   //打开接收中断
 400   1              TR1=1;                                                  //打开计数器
 401   1      }
 402          
 403          /**************************************************************
 404          * 函 数 名         : main
 405          * 函数功能                 : 实现所有功能
 406          * 输    入         : 无
 407          * 输    出         : 无
 408          ****************************************************************/
 409          void main(void)
 410          {
 411   1      
 412   1              int_init();
 413   1              LCD_Init();
 414   1              Song_Tone=Song1_Tone;
 415   1              Song_Time=Song1_Time;
 416   1              discode=dis1;
 417   1              KeyValue=1;
 418   1              LSA=0;                                                  //给一个数码管提供位选
 419   1              LSB=0;
 420   1              LSC=0;
 421   1                                        
 422   1              GPIO_DIG=smgduan[KeyValue];     //显示在数码管上 
 423   1      
 424   1      
 425   1              while(1)
 426   1              {
 427   2                         
C51 COMPILER V9.01   MAIN                                                                  01/20/2018 01:06:38 PAGE 8   

 428   2              if (K1 == 0)                    //当K1按下时，总中断打开可以播放音乐
 429   2                      {
 430   3                              EA=1;
 431   3                      }
 432   2                      if (K2 == 0)                            //当K2按下时继续或暂停播放音乐  
 433   2                      {
 434   3                              EA=~EA;
 435   3                      }
 436   2                      KeyDown();                                      //按键判断函数
 437   2                      Song_Index=KeyValue;
 438   2                      if(Song_Index==2)
 439   2                      {
 440   3                              LCD_WCMD(0x01);
 441   3                              Song_Tone=Song2_Tone;
 442   3                              Song_Time=Song2_Time;
 443   3                              discode=dis2;
 444   3                      }
 445   2                              else if(Song_Index==3)
 446   2                              {
 447   3                                      LCD_WCMD(0x01);
 448   3                                      Song_Tone=Song3_Tone;
 449   3                                      Song_Time=Song3_Time;
 450   3                                      discode=dis3;
 451   3                              }
 452   2                              else if(Song_Index==4)
 453   2                              {
 454   3                                      LCD_WCMD(0x01);
 455   3                                      Song_Tone=Song4_Tone;
 456   3                                      Song_Time=Song4_Time;
 457   3                                      discode=dis4;
 458   3                              }
 459   2                              else if(Song_Index==5)
 460   2                              {
 461   3                                      LCD_WCMD(0x01);
 462   3                                      Song_Tone=Song5_Tone;
 463   3                                      Song_Time=Song5_Time;
 464   3                                      discode=dis5;
 465   3                              }
 466   2                              else if(Song_Index==1)
 467   2                              {  
 468   3                                      LCD_WCMD(0x01);
 469   3                                      Song_Tone=Song1_Tone;
 470   3                                      Song_Time=Song1_Time;
 471   3                                      discode=dis1;
 472   3                              }
 473   2                      
 474   2                              LSA=0;                                          //给一个数码管提供位选
 475   2                              LSB=0;
 476   2                              LSC=0;
 477   2                                       
 478   2                              LCD_disp();                                     //LCD显示
 479   2                              GPIO_DIG=smgduan[KeyValue]; //显示在数码管上 
 480   2                              Tone_Index=Song_Tone[i];
 481   2                              if(Tone_Index==0xff)
 482   2                              {
 483   3                                      i=0;
 484   3                                      TR0=0;
 485   3                              }  
 486   2                              TR0=1;
 487   2                              delayms(Song_Time[Tone_Index]*60);
 488   2                              TR0=0;
 489   2                              i++;            
C51 COMPILER V9.01   MAIN                                                                  01/20/2018 01:06:38 PAGE 9   

 490   2              } 
 491   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1240    ----
   CONSTANT SIZE    =    500    ----
   XDATA SIZE       =    115       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
